/****************************************************************************
	Copyright (C), 2010 安富莱电子 www.armfly.com

   【本例程在安富莱STM32F103ZE-EK开发板上调试通过             】
   【QQ: 1295744630, 旺旺：armfly, Email: armfly@qq.com       】

	文件名： ExtSRAM.ini

	这是外部SRAM调试脚本。开始Load程序时，由IDE控制仿真器执行这段脚本程序。

	本脚本完成的功能是
	(1) 配置CPU的FSMC总线，使CPU能够访问外部SRAM，已便于后面装入程序
	(2) 复制外部SRAM的中断向量表（0x130字节）到CPU内部RAM
	(3) 设置堆栈指针SP
	(4) 修改PC指针
	
	注意：工程选项IRAM1的起始地址必须是0x20000200开始

	脚本的语法：
	参加MDK的HELP, 搜索关键字 “uv3 Library Routines” 可以看到uv3支持的脚本命令
*/

FUNC void Setup (void) {
  SP = _RDWORD(0x68000000);          // 设置堆栈指针
  PC = _RDWORD(0x68000004);          // 设置PC指针（程序计数器)
  _WDWORD(0xE000ED08, 0x20000000);   // 设置中断向量表地址寄存器 = 0x20000000
}

// 初始化FSMC，用于外部SRAM
FUNC void InitSRAM (void) {
  //InitRCCC
  _WDWORD(0x40021000, 0x00005083);
  _WDWORD(0x40021004, 0x00000000);
  _WDWORD(0x40021004, 0x00000000);
  _WDWORD(0x40021000, 0x00005083);
  _WDWORD(0x40021004, 0x00000000);
  _WDWORD(0x40021008, 0x009F0000);

  _WDWORD(0x40021000, 0x00015083);
  _sleep_ (100);                        // Wait for PLL lock

  _WDWORD(0x40022000, 0x00000030);
  _WDWORD(0x40022000, 0x00000030);
  _WDWORD(0x40022000, 0x00000032);
  _WDWORD(0x40021004, 0x00000000);
  _WDWORD(0x40021004, 0x00000000);
  _WDWORD(0x40021004, 0x00000400);
  _WDWORD(0x40021004, 0x00000400);
  _WDWORD(0x40021004, 0x001D0400);
  _WDWORD(0x40021000, 0x01035083);
  _sleep_ (100);
  _WDWORD(0x40021004, 0x001D0400);
  _WDWORD(0x40021004, 0x001D0402);
  _sleep_ (100);

  _WDWORD(0x40021014, 0x00000114);  /* Enable AHBPeriphClock */
  _WDWORD(0x40021018, 0x000001E0);  /* Enable APB2PeriphClock */

  /* GPIO Configuration for FSMC */
  _WDWORD(0x40011400, 0xB8BB44BB);
  _WDWORD(0x40011404, 0xBBBBBBBB);
  _WDWORD(0x40011800, 0xBBBBB4BB);   /* NBL0, NBL1 & adress configuration */
  _WDWORD(0x40011804, 0xBBBBBBBB);
  _WDWORD(0x40011C00, 0x33BBBBBB);
  _WDWORD(0x40011C04, 0xBBBB3333);
  _WDWORD(0x40012000, 0x48BBBBBB);
  _WDWORD(0x40012004, 0x444B4BB4);   /* NE3 configuration */

  _WDWORD(0xA0000010, 0x00001010);   /* FSMC Configuration */
  _WDWORD(0xA0000014, 0x00000200);   /* FSMC_DataSetupTime = 2; */
  _WDWORD(0xA0000010, 0x00001011);   /* Enable FSMC Bank1_SRAM Bank */

  _sleep_ (200);
}

/*
	复制中断向量表
	中断向量表地址必须是512字节的整数倍。
	中断向量表实际大小 ：0x00000130
*/
FUNC void CopyVectTable(void) {
	_WDWORD(0x20000000, _RDWORD(0x68000000));
	_WDWORD(0x20000004, _RDWORD(0x68000004));
	_WDWORD(0x20000008, _RDWORD(0x68000008));
	_WDWORD(0x2000000C, _RDWORD(0x6800000C));

	_WDWORD(0x20000010, _RDWORD(0x68000010));
	_WDWORD(0x20000014, _RDWORD(0x68000014));
	_WDWORD(0x20000018, _RDWORD(0x68000018));
	_WDWORD(0x2000001C, _RDWORD(0x6800001C));

	_WDWORD(0x20000020, _RDWORD(0x68000020));
	_WDWORD(0x20000024, _RDWORD(0x68000024));
	_WDWORD(0x20000028, _RDWORD(0x68000028));
	_WDWORD(0x2000002C, _RDWORD(0x6800002C));

	_WDWORD(0x20000030, _RDWORD(0x68000030));
	_WDWORD(0x20000034, _RDWORD(0x68000034));
	_WDWORD(0x20000038, _RDWORD(0x68000038));
	_WDWORD(0x2000003C, _RDWORD(0x6800003C));

	_WDWORD(0x20000040, _RDWORD(0x68000040));
	_WDWORD(0x20000044, _RDWORD(0x68000044));
	_WDWORD(0x20000048, _RDWORD(0x68000048));
	_WDWORD(0x2000004C, _RDWORD(0x6800004C));

	_WDWORD(0x20000050, _RDWORD(0x68000050));
	_WDWORD(0x20000054, _RDWORD(0x68000054));
	_WDWORD(0x20000058, _RDWORD(0x68000058));
	_WDWORD(0x2000005C, _RDWORD(0x6800005C));

	_WDWORD(0x20000060, _RDWORD(0x68000060));
	_WDWORD(0x20000064, _RDWORD(0x68000064));
	_WDWORD(0x20000068, _RDWORD(0x68000068));
	_WDWORD(0x2000006C, _RDWORD(0x6800006C));

	_WDWORD(0x20000070, _RDWORD(0x68000070));
	_WDWORD(0x20000074, _RDWORD(0x68000074));
	_WDWORD(0x20000078, _RDWORD(0x68000078));
	_WDWORD(0x2000007C, _RDWORD(0x6800007C));

	_WDWORD(0x20000080, _RDWORD(0x68000080));
	_WDWORD(0x20000084, _RDWORD(0x68000084));
	_WDWORD(0x20000088, _RDWORD(0x68000088));
	_WDWORD(0x2000008C, _RDWORD(0x6800008C));

	_WDWORD(0x20000090, _RDWORD(0x68000090));
	_WDWORD(0x20000094, _RDWORD(0x68000094));
	_WDWORD(0x20000098, _RDWORD(0x68000098));
	_WDWORD(0x2000009C, _RDWORD(0x6800009C));

	_WDWORD(0x200000A0, _RDWORD(0x680000A0));
	_WDWORD(0x200000A4, _RDWORD(0x680000A4));
	_WDWORD(0x200000A8, _RDWORD(0x680000A8));
	_WDWORD(0x200000AC, _RDWORD(0x680000AC));

	_WDWORD(0x200000B0, _RDWORD(0x680000B0));
	_WDWORD(0x200000B4, _RDWORD(0x680000B4));
	_WDWORD(0x200000B8, _RDWORD(0x680000B8));
	_WDWORD(0x200000BC, _RDWORD(0x680000BC));

	_WDWORD(0x200000C0, _RDWORD(0x680000C0));
	_WDWORD(0x200000C4, _RDWORD(0x680000C4));
	_WDWORD(0x200000C8, _RDWORD(0x680000C8));
	_WDWORD(0x200000CC, _RDWORD(0x680000CC));

	_WDWORD(0x200000D0, _RDWORD(0x680000D0));
	_WDWORD(0x200000D4, _RDWORD(0x680000D4));
	_WDWORD(0x200000D8, _RDWORD(0x680000D8));
	_WDWORD(0x200000DC, _RDWORD(0x680000DC));

	_WDWORD(0x200000E0, _RDWORD(0x680000E0));
	_WDWORD(0x200000E4, _RDWORD(0x680000E4));
	_WDWORD(0x200000E8, _RDWORD(0x680000E8));
	_WDWORD(0x200000EC, _RDWORD(0x680000EC));

	_WDWORD(0x200000F0, _RDWORD(0x680000F0));
	_WDWORD(0x200000F4, _RDWORD(0x680000F4));
	_WDWORD(0x200000F8, _RDWORD(0x680000F8));
	_WDWORD(0x200000FC, _RDWORD(0x680000FC));

	_WDWORD(0x20000100, _RDWORD(0x68000100));
	_WDWORD(0x20000104, _RDWORD(0x68000104));
	_WDWORD(0x20000108, _RDWORD(0x68000108));
	_WDWORD(0x2000010C, _RDWORD(0x6800010C));

	_WDWORD(0x20000110, _RDWORD(0x68000110));
	_WDWORD(0x20000114, _RDWORD(0x68000114));
	_WDWORD(0x20000118, _RDWORD(0x68000118));
	_WDWORD(0x2000011C, _RDWORD(0x6800011C));

	_WDWORD(0x20000120, _RDWORD(0x68000120));
	_WDWORD(0x20000124, _RDWORD(0x68000124));
	_WDWORD(0x20000128, _RDWORD(0x68000128));
	_WDWORD(0x2000012C, _RDWORD(0x6800012C));
}

// 从这里开始执行代码，之前的都是函数定义
InitSRAM();                   		// 配置 FSMC用于SRAM
LOAD ExtSRAM\obj\output.axf INCREMENTAL		// 下载程序到外部SRAM
CopyVectTable();					// 将外部SRAM的中断向量表复制到CPU内部RAM
Setup();                     		// 配置堆栈和PC指针
g, main								// 运行到 main()函数后暂停
